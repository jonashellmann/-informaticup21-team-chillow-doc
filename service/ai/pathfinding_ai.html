<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>chillow.service.ai.pathfinding_ai API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>chillow.service.ai.pathfinding_ai</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import operator
from multiprocessing import Value
from typing import List, Tuple, Optional
from random import shuffle
from pathfinding.core.diagonal_movement import DiagonalMovement
from pathfinding.core.grid import Grid
from pathfinding.finder.best_first import BestFirst

from chillow.service.ai import NotKillingItselfAI
from chillow.exceptions import InvalidPlayerMoveException
from chillow.model.action import Action
from chillow.model.game import Game
from chillow.model.player import Player
from chillow.service.game_service import GameService


class PathfindingAI(NotKillingItselfAI):
    &#34;&#34;&#34;AI implementation that chooses actions which will allow it to survive a certain number of moves.

    It does not consider enemy actions. Furthermore, the AI avoids running into too small areas or dead ends.

    Attributes:
        player: The player associated with this AI.
    &#34;&#34;&#34;

    def __init__(self, player: Player, max_speed: int, count_paths_to_check: int):
        &#34;&#34;&#34;Creates a new object of the PathfindingAI.

        Args:
            player: The player assigned to the AI.
            max_speed: The maximum speed the AI can reach.
            count_paths_to_check: The number of paths used to avoid dead ends.
        &#34;&#34;&#34;
        super().__init__(player, [], max_speed, 0, 3)
        self.__count_paths_to_check = count_paths_to_check

    def get_information(self) -&gt; str:
        &#34;&#34;&#34;See base class.&#34;&#34;&#34;
        return &#34;max_speed=&#34; + str(self._max_speed) \
               + &#34;, count_paths_to_check=&#34; + str(self.__count_paths_to_check)

    def create_next_action(self, game: Game, return_value: Value):
        &#34;&#34;&#34;See base class.&#34;&#34;&#34;
        self._turn_ctr += 1
        actions = self.create_next_actions_ranked(game)
        action = actions[0][0] if actions is not None and len(actions) &gt; 0 else Action.get_random_action()
        return_value.value = action.get_index()

    def create_next_actions_ranked(self, game: Game) -&gt; Optional[List[Tuple[Action, int]]]:
        &#34;&#34;&#34;Calculates all actions with the number of reachable paths, with which the AI won&#39;t lose in the next turn.

        Args:
            game: The game object in which the AI is located and which contains the current status of the game.

        Returns:
            A list with actions and the corresponding number of accessible paths.
        &#34;&#34;&#34;
        game_service = GameService(game)
        game_service.turn.turn_ctr = self._turn_ctr

        surviving_actions = self.find_surviving_actions_with_best_depth(game_service)

        return self.find_actions_by_best_path_connection(surviving_actions, game)

    def find_actions_by_best_path_connection(self, actions: List[Action], game: Game) -&gt; Optional[
            List[Tuple[Action, int]]]:
        &#34;&#34;&#34; Calculates for the passed actions how many paths are still accessible after the execution of the action.

        For this purpose, points are randomly generated on the playing field and an algorithm for finding paths is
        used to check whether the point can be reached.

        Args:
            actions: List of actions to check.
            game: The game that contains the current state of the game.

        Returns:
            List of actions with the accessible paths.
        &#34;&#34;&#34;
        if actions is None or len(actions) == 0:
            return None
        # shuffle the actions, so that different actions are chosen if they have the same quality and the AI is not so
        # easily predictable.
        shuffle(actions)
        actions_with_possible_paths: List[Tuple[Action, int]] = []
        free_cells_for_pathfinding = self.get_random_free_cells_from_playground(game)

        path_finder = BestFirst(diagonal_movement=DiagonalMovement.never)

        for action in actions:
            game_copy = game.copy()
            game_service = GameService(game_copy)
            try:
                player = game_service.game.get_player_by_id(self.player.id)
                game_service.visited_cells_by_player[player.id] = game_service.get_and_visit_cells(player, action)
            except InvalidPlayerMoveException:
                continue

            matrix = game_copy.translate_cell_matrix_to_pathfinding_matrix()
            current_possible_paths = 0
            length_free_cells = len(free_cells_for_pathfinding)
            for i in range(length_free_cells):
                grid = Grid(matrix=matrix)
                start = grid.node(player.x, player.y)
                end = grid.node(free_cells_for_pathfinding[i][0], free_cells_for_pathfinding[i][1])
                path, runs = path_finder.find_path(start, end, grid)
                if len(path) &gt; 0:  # a path exists
                    current_possible_paths += 1

            actions_with_possible_paths.append((action, current_possible_paths))
        # Action with most accessible paths at index 0
        actions_with_possible_paths.sort(key=operator.itemgetter(1), reverse=True)
        return actions_with_possible_paths

    def get_random_free_cells_from_playground(self, game: Game) -&gt; List[Tuple[int, int]]:
        &#34;&#34;&#34;Calculates up to count_paths_to_check many points of all free fields on the playing field.

        Args:
            game: The game that contains the current state of the game.

        Returns:
            List of coordinates with x- and y-value.
        &#34;&#34;&#34;
        free_cells: List[(int, int)] = []
        for x in range(game.width):
            for y in range(game.height):
                if game.cells[y][x].players is None or len(game.cells[y][x].players) == 0:
                    free_cells.append((x, y))
        shuffle(free_cells)  # shuffle the coordinates to get a random distribution
        return free_cells[:min(self.__count_paths_to_check, len(free_cells))]

    def _get_count_paths_to_check(self) -&gt; int:
        return self.__count_paths_to_check</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="chillow.service.ai.pathfinding_ai.PathfindingAI"><code class="flex name class">
<span>class <span class="ident">PathfindingAI</span></span>
<span>(</span><span>player: <a title="chillow.model.player.Player" href="../../model/player.html#chillow.model.player.Player">Player</a>, max_speed: int, count_paths_to_check: int)</span>
</code></dt>
<dd>
<div class="desc"><p>AI implementation that chooses actions which will allow it to survive a certain number of moves.</p>
<p>It does not consider enemy actions. Furthermore, the AI avoids running into too small areas or dead ends.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player associated with this AI.</dd>
</dl>
<p>Creates a new object of the PathfindingAI.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player assigned to the AI.</dd>
<dt><strong><code>max_speed</code></strong></dt>
<dd>The maximum speed the AI can reach.</dd>
<dt><strong><code>count_paths_to_check</code></strong></dt>
<dd>The number of paths used to avoid dead ends.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PathfindingAI(NotKillingItselfAI):
    &#34;&#34;&#34;AI implementation that chooses actions which will allow it to survive a certain number of moves.

    It does not consider enemy actions. Furthermore, the AI avoids running into too small areas or dead ends.

    Attributes:
        player: The player associated with this AI.
    &#34;&#34;&#34;

    def __init__(self, player: Player, max_speed: int, count_paths_to_check: int):
        &#34;&#34;&#34;Creates a new object of the PathfindingAI.

        Args:
            player: The player assigned to the AI.
            max_speed: The maximum speed the AI can reach.
            count_paths_to_check: The number of paths used to avoid dead ends.
        &#34;&#34;&#34;
        super().__init__(player, [], max_speed, 0, 3)
        self.__count_paths_to_check = count_paths_to_check

    def get_information(self) -&gt; str:
        &#34;&#34;&#34;See base class.&#34;&#34;&#34;
        return &#34;max_speed=&#34; + str(self._max_speed) \
               + &#34;, count_paths_to_check=&#34; + str(self.__count_paths_to_check)

    def create_next_action(self, game: Game, return_value: Value):
        &#34;&#34;&#34;See base class.&#34;&#34;&#34;
        self._turn_ctr += 1
        actions = self.create_next_actions_ranked(game)
        action = actions[0][0] if actions is not None and len(actions) &gt; 0 else Action.get_random_action()
        return_value.value = action.get_index()

    def create_next_actions_ranked(self, game: Game) -&gt; Optional[List[Tuple[Action, int]]]:
        &#34;&#34;&#34;Calculates all actions with the number of reachable paths, with which the AI won&#39;t lose in the next turn.

        Args:
            game: The game object in which the AI is located and which contains the current status of the game.

        Returns:
            A list with actions and the corresponding number of accessible paths.
        &#34;&#34;&#34;
        game_service = GameService(game)
        game_service.turn.turn_ctr = self._turn_ctr

        surviving_actions = self.find_surviving_actions_with_best_depth(game_service)

        return self.find_actions_by_best_path_connection(surviving_actions, game)

    def find_actions_by_best_path_connection(self, actions: List[Action], game: Game) -&gt; Optional[
            List[Tuple[Action, int]]]:
        &#34;&#34;&#34; Calculates for the passed actions how many paths are still accessible after the execution of the action.

        For this purpose, points are randomly generated on the playing field and an algorithm for finding paths is
        used to check whether the point can be reached.

        Args:
            actions: List of actions to check.
            game: The game that contains the current state of the game.

        Returns:
            List of actions with the accessible paths.
        &#34;&#34;&#34;
        if actions is None or len(actions) == 0:
            return None
        # shuffle the actions, so that different actions are chosen if they have the same quality and the AI is not so
        # easily predictable.
        shuffle(actions)
        actions_with_possible_paths: List[Tuple[Action, int]] = []
        free_cells_for_pathfinding = self.get_random_free_cells_from_playground(game)

        path_finder = BestFirst(diagonal_movement=DiagonalMovement.never)

        for action in actions:
            game_copy = game.copy()
            game_service = GameService(game_copy)
            try:
                player = game_service.game.get_player_by_id(self.player.id)
                game_service.visited_cells_by_player[player.id] = game_service.get_and_visit_cells(player, action)
            except InvalidPlayerMoveException:
                continue

            matrix = game_copy.translate_cell_matrix_to_pathfinding_matrix()
            current_possible_paths = 0
            length_free_cells = len(free_cells_for_pathfinding)
            for i in range(length_free_cells):
                grid = Grid(matrix=matrix)
                start = grid.node(player.x, player.y)
                end = grid.node(free_cells_for_pathfinding[i][0], free_cells_for_pathfinding[i][1])
                path, runs = path_finder.find_path(start, end, grid)
                if len(path) &gt; 0:  # a path exists
                    current_possible_paths += 1

            actions_with_possible_paths.append((action, current_possible_paths))
        # Action with most accessible paths at index 0
        actions_with_possible_paths.sort(key=operator.itemgetter(1), reverse=True)
        return actions_with_possible_paths

    def get_random_free_cells_from_playground(self, game: Game) -&gt; List[Tuple[int, int]]:
        &#34;&#34;&#34;Calculates up to count_paths_to_check many points of all free fields on the playing field.

        Args:
            game: The game that contains the current state of the game.

        Returns:
            List of coordinates with x- and y-value.
        &#34;&#34;&#34;
        free_cells: List[(int, int)] = []
        for x in range(game.width):
            for y in range(game.height):
                if game.cells[y][x].players is None or len(game.cells[y][x].players) == 0:
                    free_cells.append((x, y))
        shuffle(free_cells)  # shuffle the coordinates to get a random distribution
        return free_cells[:min(self.__count_paths_to_check, len(free_cells))]

    def _get_count_paths_to_check(self) -&gt; int:
        return self.__count_paths_to_check</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI" href="not_killing_itself_ai.html#chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI">NotKillingItselfAI</a></li>
<li><a title="chillow.service.ai.artificial_intelligence.ArtificialIntelligence" href="artificial_intelligence.html#chillow.service.ai.artificial_intelligence.ArtificialIntelligence">ArtificialIntelligence</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="chillow.service.ai.pathfinding_search_tree_ai.PathfindingSearchTreeAI" href="pathfinding_search_tree_ai.html#chillow.service.ai.pathfinding_search_tree_ai.PathfindingSearchTreeAI">PathfindingSearchTreeAI</a></li>
<li><a title="chillow.service.ai.search_tree_pathfinding_ai.SearchTreePathfindingAI" href="search_tree_pathfinding_ai.html#chillow.service.ai.search_tree_pathfinding_ai.SearchTreePathfindingAI">SearchTreePathfindingAI</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="chillow.service.ai.pathfinding_ai.PathfindingAI.create_next_actions_ranked"><code class="name flex">
<span>def <span class="ident">create_next_actions_ranked</span></span>(<span>self, game: <a title="chillow.model.game.Game" href="../../model/game.html#chillow.model.game.Game">Game</a>) ‑> Optional[List[Tuple[<a title="chillow.model.action.Action" href="../../model/action.html#chillow.model.action.Action">Action</a>, int]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates all actions with the number of reachable paths, with which the AI won't lose in the next turn.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game</code></strong></dt>
<dd>The game object in which the AI is located and which contains the current status of the game.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list with actions and the corresponding number of accessible paths.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_next_actions_ranked(self, game: Game) -&gt; Optional[List[Tuple[Action, int]]]:
    &#34;&#34;&#34;Calculates all actions with the number of reachable paths, with which the AI won&#39;t lose in the next turn.

    Args:
        game: The game object in which the AI is located and which contains the current status of the game.

    Returns:
        A list with actions and the corresponding number of accessible paths.
    &#34;&#34;&#34;
    game_service = GameService(game)
    game_service.turn.turn_ctr = self._turn_ctr

    surviving_actions = self.find_surviving_actions_with_best_depth(game_service)

    return self.find_actions_by_best_path_connection(surviving_actions, game)</code></pre>
</details>
</dd>
<dt id="chillow.service.ai.pathfinding_ai.PathfindingAI.find_actions_by_best_path_connection"><code class="name flex">
<span>def <span class="ident">find_actions_by_best_path_connection</span></span>(<span>self, actions: List[<a title="chillow.model.action.Action" href="../../model/action.html#chillow.model.action.Action">Action</a>], game: <a title="chillow.model.game.Game" href="../../model/game.html#chillow.model.game.Game">Game</a>) ‑> Optional[List[Tuple[<a title="chillow.model.action.Action" href="../../model/action.html#chillow.model.action.Action">Action</a>, int]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates for the passed actions how many paths are still accessible after the execution of the action.</p>
<p>For this purpose, points are randomly generated on the playing field and an algorithm for finding paths is
used to check whether the point can be reached.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>actions</code></strong></dt>
<dd>List of actions to check.</dd>
<dt><strong><code>game</code></strong></dt>
<dd>The game that contains the current state of the game.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of actions with the accessible paths.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_actions_by_best_path_connection(self, actions: List[Action], game: Game) -&gt; Optional[
        List[Tuple[Action, int]]]:
    &#34;&#34;&#34; Calculates for the passed actions how many paths are still accessible after the execution of the action.

    For this purpose, points are randomly generated on the playing field and an algorithm for finding paths is
    used to check whether the point can be reached.

    Args:
        actions: List of actions to check.
        game: The game that contains the current state of the game.

    Returns:
        List of actions with the accessible paths.
    &#34;&#34;&#34;
    if actions is None or len(actions) == 0:
        return None
    # shuffle the actions, so that different actions are chosen if they have the same quality and the AI is not so
    # easily predictable.
    shuffle(actions)
    actions_with_possible_paths: List[Tuple[Action, int]] = []
    free_cells_for_pathfinding = self.get_random_free_cells_from_playground(game)

    path_finder = BestFirst(diagonal_movement=DiagonalMovement.never)

    for action in actions:
        game_copy = game.copy()
        game_service = GameService(game_copy)
        try:
            player = game_service.game.get_player_by_id(self.player.id)
            game_service.visited_cells_by_player[player.id] = game_service.get_and_visit_cells(player, action)
        except InvalidPlayerMoveException:
            continue

        matrix = game_copy.translate_cell_matrix_to_pathfinding_matrix()
        current_possible_paths = 0
        length_free_cells = len(free_cells_for_pathfinding)
        for i in range(length_free_cells):
            grid = Grid(matrix=matrix)
            start = grid.node(player.x, player.y)
            end = grid.node(free_cells_for_pathfinding[i][0], free_cells_for_pathfinding[i][1])
            path, runs = path_finder.find_path(start, end, grid)
            if len(path) &gt; 0:  # a path exists
                current_possible_paths += 1

        actions_with_possible_paths.append((action, current_possible_paths))
    # Action with most accessible paths at index 0
    actions_with_possible_paths.sort(key=operator.itemgetter(1), reverse=True)
    return actions_with_possible_paths</code></pre>
</details>
</dd>
<dt id="chillow.service.ai.pathfinding_ai.PathfindingAI.get_random_free_cells_from_playground"><code class="name flex">
<span>def <span class="ident">get_random_free_cells_from_playground</span></span>(<span>self, game: <a title="chillow.model.game.Game" href="../../model/game.html#chillow.model.game.Game">Game</a>) ‑> List[Tuple[int, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates up to count_paths_to_check many points of all free fields on the playing field.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game</code></strong></dt>
<dd>The game that contains the current state of the game.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of coordinates with x- and y-value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_random_free_cells_from_playground(self, game: Game) -&gt; List[Tuple[int, int]]:
    &#34;&#34;&#34;Calculates up to count_paths_to_check many points of all free fields on the playing field.

    Args:
        game: The game that contains the current state of the game.

    Returns:
        List of coordinates with x- and y-value.
    &#34;&#34;&#34;
    free_cells: List[(int, int)] = []
    for x in range(game.width):
        for y in range(game.height):
            if game.cells[y][x].players is None or len(game.cells[y][x].players) == 0:
                free_cells.append((x, y))
    shuffle(free_cells)  # shuffle the coordinates to get a random distribution
    return free_cells[:min(self.__count_paths_to_check, len(free_cells))]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI" href="not_killing_itself_ai.html#chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI">NotKillingItselfAI</a></b></code>:
<ul class="hlist">
<li><code><a title="chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.calc_action_with_max_distance_to_visited_cells" href="not_killing_itself_ai.html#chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.calc_action_with_max_distance_to_visited_cells">calc_action_with_max_distance_to_visited_cells</a></code></li>
<li><code><a title="chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.create_next_action" href="not_killing_itself_ai.html#chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.create_next_action">create_next_action</a></code></li>
<li><code><a title="chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.find_surviving_actions" href="not_killing_itself_ai.html#chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.find_surviving_actions">find_surviving_actions</a></code></li>
<li><code><a title="chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.find_surviving_actions_with_best_depth" href="not_killing_itself_ai.html#chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.find_surviving_actions_with_best_depth">find_surviving_actions_with_best_depth</a></code></li>
<li><code><a title="chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.get_information" href="not_killing_itself_ai.html#chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.get_information">get_information</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="chillow.service.ai" href="index.html">chillow.service.ai</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="chillow.service.ai.pathfinding_ai.PathfindingAI" href="#chillow.service.ai.pathfinding_ai.PathfindingAI">PathfindingAI</a></code></h4>
<ul class="">
<li><code><a title="chillow.service.ai.pathfinding_ai.PathfindingAI.create_next_actions_ranked" href="#chillow.service.ai.pathfinding_ai.PathfindingAI.create_next_actions_ranked">create_next_actions_ranked</a></code></li>
<li><code><a title="chillow.service.ai.pathfinding_ai.PathfindingAI.find_actions_by_best_path_connection" href="#chillow.service.ai.pathfinding_ai.PathfindingAI.find_actions_by_best_path_connection">find_actions_by_best_path_connection</a></code></li>
<li><code><a title="chillow.service.ai.pathfinding_ai.PathfindingAI.get_random_free_cells_from_playground" href="#chillow.service.ai.pathfinding_ai.PathfindingAI.get_random_free_cells_from_playground">get_random_free_cells_from_playground</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>