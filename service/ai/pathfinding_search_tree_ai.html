<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>chillow.service.ai.pathfinding_search_tree_ai API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>chillow.service.ai.pathfinding_search_tree_ai</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import List, Tuple, Optional
from multiprocessing import Value

from chillow.service.ai.pathfinding_ai import PathfindingAI
from chillow.service.ai.search_tree_ai import SearchTreeAI
from chillow.model.action import Action
from chillow.model.game import Game
from chillow.model.player import Player


class PathfindingSearchTreeAI(PathfindingAI, SearchTreeAI):
    &#34;&#34;&#34;This AI combines the PathfindingAI and the SearchTreeAI by favoring the former.

    Therefore it ranks all actions based on the PathfindingAI and checks finds the first surviving action with the
    SearchTreeAI.

    Attributes:
        player: The player associated with this AI.
    &#34;&#34;&#34;

    def __init__(self, player: Player, max_speed: int, count_paths_to_check: int, depth: int,
                 paths_tolerance: float = 0.75, distance_to_check: int = 0):
        &#34;&#34;&#34;Creates a new object of the PathfindingSearchTreeAI.

        Args:
            player: The player assigned to the AI.
            max_speed: The maximum speed the AI can reach.
            count_paths_to_check: The number of paths used to avoid dead ends.
            depth: Depth pre-calculating actions.
            paths_tolerance: A tolerance, whereby more than just the best action is calculated. Actions which are
                worse, but within this tolerance, are also considered.
                depth: Number of player actions that are looked into the future.
            distance_to_check: Distance an enemy player is allowed to be at maximum distance, so that he is taken into
                account in the calculations.
        &#34;&#34;&#34;
        PathfindingAI.__init__(self, player, max_speed, count_paths_to_check)
        SearchTreeAI.__init__(self, player, depth, max_speed, distance_to_check=distance_to_check)
        self.__paths_tolerance = paths_tolerance

    def get_information(self) -&gt; str:
        &#34;&#34;&#34;See base class.&#34;&#34;&#34;
        return &#34;max_speed=&#34; + str(self._max_speed) \
               + &#34;, paths_tolerance=&#34; + str(self.__paths_tolerance) \
               + &#34;, count_paths_to_check=&#34; + str(self._get_count_paths_to_check()) \
               + &#34;, depth=&#34; + str(self._get_depth()) \
               + &#34;, distance_to_check=&#34; + str(self._get_distance_to_check())

    def create_next_action(self, game: Game, return_value: Value):
        &#34;&#34;&#34;See base class.&#34;&#34;&#34;
        self._turn_ctr += 1

        pathfinding_actions = self.create_next_actions_ranked(game)
        self.set_best_action(pathfinding_actions, [], return_value)
        search_tree_actions = self.create_all_next_surviving_actions(game)
        self.set_best_action(pathfinding_actions, search_tree_actions, return_value)

    def set_best_action(self, pathfinding_actions: List[Tuple[Action, int]], search_tree_actions: List[Action],
                        return_value: Value):
        &#34;&#34;&#34;Saves the best action from the list of actions from PathfindingAI and SearchTreeAI.

        Args:
            pathfinding_actions: List of actions calculated by PathfindingAI.
            search_tree_actions: List of actions calculated by SearchTreeAI
            return_value: Object to save the result of the calculation.
        &#34;&#34;&#34;
        best_action = self.get_best_action(pathfinding_actions, search_tree_actions)
        return_value.value = best_action.get_index() if best_action is not None else return_value.value

    def get_best_action(self, pathfinding_actions: List[Tuple[Action, int]],
                        search_tree_actions: List[Action]) -&gt; Optional[Action]:
        &#34;&#34;&#34;Calculates the best action from the list of actions from PathfindingAI and SearchTreeAI.

        Args:
            pathfinding_actions: List of actions calculated by PathfindingAI.
            search_tree_actions: List of actions calculated by SearchTreeAI

        Returns:
            Best action if there is any.
        &#34;&#34;&#34;
        if search_tree_actions is None or len(search_tree_actions) == 0:
            if pathfinding_actions is not None and len(pathfinding_actions) &gt; 0:
                return pathfinding_actions[0][0]
            return None
        elif pathfinding_actions is None or len(pathfinding_actions) == 0:
            return search_tree_actions[0]

        for (action, possible_paths) in pathfinding_actions:
            if action in search_tree_actions:
                if possible_paths == pathfinding_actions[0][1]:
                    return action  # best path and surviving guaranteed
                elif possible_paths &gt;= pathfinding_actions[0][1] * self.__paths_tolerance:
                    return action  # good path and surviving guaranteed
                else:
                    break

        return pathfinding_actions[0][0]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="chillow.service.ai.pathfinding_search_tree_ai.PathfindingSearchTreeAI"><code class="flex name class">
<span>class <span class="ident">PathfindingSearchTreeAI</span></span>
<span>(</span><span>player: <a title="chillow.model.player.Player" href="../../model/player.html#chillow.model.player.Player">Player</a>, max_speed: int, count_paths_to_check: int, depth: int, paths_tolerance: float = 0.75, distance_to_check: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>This AI combines the PathfindingAI and the SearchTreeAI by favoring the former.</p>
<p>Therefore it ranks all actions based on the PathfindingAI and checks finds the first surviving action with the
SearchTreeAI.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player associated with this AI.</dd>
</dl>
<p>Creates a new object of the PathfindingSearchTreeAI.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player assigned to the AI.</dd>
<dt><strong><code>max_speed</code></strong></dt>
<dd>The maximum speed the AI can reach.</dd>
<dt><strong><code>count_paths_to_check</code></strong></dt>
<dd>The number of paths used to avoid dead ends.</dd>
<dt><strong><code>depth</code></strong></dt>
<dd>Depth pre-calculating actions.</dd>
<dt><strong><code>paths_tolerance</code></strong></dt>
<dd>A tolerance, whereby more than just the best action is calculated. Actions which are
worse, but within this tolerance, are also considered.
depth: Number of player actions that are looked into the future.</dd>
<dt><strong><code>distance_to_check</code></strong></dt>
<dd>Distance an enemy player is allowed to be at maximum distance, so that he is taken into
account in the calculations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PathfindingSearchTreeAI(PathfindingAI, SearchTreeAI):
    &#34;&#34;&#34;This AI combines the PathfindingAI and the SearchTreeAI by favoring the former.

    Therefore it ranks all actions based on the PathfindingAI and checks finds the first surviving action with the
    SearchTreeAI.

    Attributes:
        player: The player associated with this AI.
    &#34;&#34;&#34;

    def __init__(self, player: Player, max_speed: int, count_paths_to_check: int, depth: int,
                 paths_tolerance: float = 0.75, distance_to_check: int = 0):
        &#34;&#34;&#34;Creates a new object of the PathfindingSearchTreeAI.

        Args:
            player: The player assigned to the AI.
            max_speed: The maximum speed the AI can reach.
            count_paths_to_check: The number of paths used to avoid dead ends.
            depth: Depth pre-calculating actions.
            paths_tolerance: A tolerance, whereby more than just the best action is calculated. Actions which are
                worse, but within this tolerance, are also considered.
                depth: Number of player actions that are looked into the future.
            distance_to_check: Distance an enemy player is allowed to be at maximum distance, so that he is taken into
                account in the calculations.
        &#34;&#34;&#34;
        PathfindingAI.__init__(self, player, max_speed, count_paths_to_check)
        SearchTreeAI.__init__(self, player, depth, max_speed, distance_to_check=distance_to_check)
        self.__paths_tolerance = paths_tolerance

    def get_information(self) -&gt; str:
        &#34;&#34;&#34;See base class.&#34;&#34;&#34;
        return &#34;max_speed=&#34; + str(self._max_speed) \
               + &#34;, paths_tolerance=&#34; + str(self.__paths_tolerance) \
               + &#34;, count_paths_to_check=&#34; + str(self._get_count_paths_to_check()) \
               + &#34;, depth=&#34; + str(self._get_depth()) \
               + &#34;, distance_to_check=&#34; + str(self._get_distance_to_check())

    def create_next_action(self, game: Game, return_value: Value):
        &#34;&#34;&#34;See base class.&#34;&#34;&#34;
        self._turn_ctr += 1

        pathfinding_actions = self.create_next_actions_ranked(game)
        self.set_best_action(pathfinding_actions, [], return_value)
        search_tree_actions = self.create_all_next_surviving_actions(game)
        self.set_best_action(pathfinding_actions, search_tree_actions, return_value)

    def set_best_action(self, pathfinding_actions: List[Tuple[Action, int]], search_tree_actions: List[Action],
                        return_value: Value):
        &#34;&#34;&#34;Saves the best action from the list of actions from PathfindingAI and SearchTreeAI.

        Args:
            pathfinding_actions: List of actions calculated by PathfindingAI.
            search_tree_actions: List of actions calculated by SearchTreeAI
            return_value: Object to save the result of the calculation.
        &#34;&#34;&#34;
        best_action = self.get_best_action(pathfinding_actions, search_tree_actions)
        return_value.value = best_action.get_index() if best_action is not None else return_value.value

    def get_best_action(self, pathfinding_actions: List[Tuple[Action, int]],
                        search_tree_actions: List[Action]) -&gt; Optional[Action]:
        &#34;&#34;&#34;Calculates the best action from the list of actions from PathfindingAI and SearchTreeAI.

        Args:
            pathfinding_actions: List of actions calculated by PathfindingAI.
            search_tree_actions: List of actions calculated by SearchTreeAI

        Returns:
            Best action if there is any.
        &#34;&#34;&#34;
        if search_tree_actions is None or len(search_tree_actions) == 0:
            if pathfinding_actions is not None and len(pathfinding_actions) &gt; 0:
                return pathfinding_actions[0][0]
            return None
        elif pathfinding_actions is None or len(pathfinding_actions) == 0:
            return search_tree_actions[0]

        for (action, possible_paths) in pathfinding_actions:
            if action in search_tree_actions:
                if possible_paths == pathfinding_actions[0][1]:
                    return action  # best path and surviving guaranteed
                elif possible_paths &gt;= pathfinding_actions[0][1] * self.__paths_tolerance:
                    return action  # good path and surviving guaranteed
                else:
                    break

        return pathfinding_actions[0][0]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="chillow.service.ai.pathfinding_ai.PathfindingAI" href="pathfinding_ai.html#chillow.service.ai.pathfinding_ai.PathfindingAI">PathfindingAI</a></li>
<li><a title="chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI" href="not_killing_itself_ai.html#chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI">NotKillingItselfAI</a></li>
<li><a title="chillow.service.ai.search_tree_ai.SearchTreeAI" href="search_tree_ai.html#chillow.service.ai.search_tree_ai.SearchTreeAI">SearchTreeAI</a></li>
<li><a title="chillow.service.ai.artificial_intelligence.ArtificialIntelligence" href="artificial_intelligence.html#chillow.service.ai.artificial_intelligence.ArtificialIntelligence">ArtificialIntelligence</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="chillow.service.ai.pathfinding_search_tree_ai.PathfindingSearchTreeAI.get_best_action"><code class="name flex">
<span>def <span class="ident">get_best_action</span></span>(<span>self, pathfinding_actions: List[Tuple[<a title="chillow.model.action.Action" href="../../model/action.html#chillow.model.action.Action">Action</a>, int]], search_tree_actions: List[<a title="chillow.model.action.Action" href="../../model/action.html#chillow.model.action.Action">Action</a>]) ‑> Optional[<a title="chillow.model.action.Action" href="../../model/action.html#chillow.model.action.Action">Action</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the best action from the list of actions from PathfindingAI and SearchTreeAI.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathfinding_actions</code></strong></dt>
<dd>List of actions calculated by PathfindingAI.</dd>
<dt><strong><code>search_tree_actions</code></strong></dt>
<dd>List of actions calculated by SearchTreeAI</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Best action if there is any.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_best_action(self, pathfinding_actions: List[Tuple[Action, int]],
                    search_tree_actions: List[Action]) -&gt; Optional[Action]:
    &#34;&#34;&#34;Calculates the best action from the list of actions from PathfindingAI and SearchTreeAI.

    Args:
        pathfinding_actions: List of actions calculated by PathfindingAI.
        search_tree_actions: List of actions calculated by SearchTreeAI

    Returns:
        Best action if there is any.
    &#34;&#34;&#34;
    if search_tree_actions is None or len(search_tree_actions) == 0:
        if pathfinding_actions is not None and len(pathfinding_actions) &gt; 0:
            return pathfinding_actions[0][0]
        return None
    elif pathfinding_actions is None or len(pathfinding_actions) == 0:
        return search_tree_actions[0]

    for (action, possible_paths) in pathfinding_actions:
        if action in search_tree_actions:
            if possible_paths == pathfinding_actions[0][1]:
                return action  # best path and surviving guaranteed
            elif possible_paths &gt;= pathfinding_actions[0][1] * self.__paths_tolerance:
                return action  # good path and surviving guaranteed
            else:
                break

    return pathfinding_actions[0][0]</code></pre>
</details>
</dd>
<dt id="chillow.service.ai.pathfinding_search_tree_ai.PathfindingSearchTreeAI.set_best_action"><code class="name flex">
<span>def <span class="ident">set_best_action</span></span>(<span>self, pathfinding_actions: List[Tuple[<a title="chillow.model.action.Action" href="../../model/action.html#chillow.model.action.Action">Action</a>, int]], search_tree_actions: List[<a title="chillow.model.action.Action" href="../../model/action.html#chillow.model.action.Action">Action</a>], return_value: <bound method BaseContext.Value of <multiprocessing.context.DefaultContext object at 0x000001CE7FAF3C70>>)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the best action from the list of actions from PathfindingAI and SearchTreeAI.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pathfinding_actions</code></strong></dt>
<dd>List of actions calculated by PathfindingAI.</dd>
<dt><strong><code>search_tree_actions</code></strong></dt>
<dd>List of actions calculated by SearchTreeAI</dd>
<dt><strong><code>return_value</code></strong></dt>
<dd>Object to save the result of the calculation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_best_action(self, pathfinding_actions: List[Tuple[Action, int]], search_tree_actions: List[Action],
                    return_value: Value):
    &#34;&#34;&#34;Saves the best action from the list of actions from PathfindingAI and SearchTreeAI.

    Args:
        pathfinding_actions: List of actions calculated by PathfindingAI.
        search_tree_actions: List of actions calculated by SearchTreeAI
        return_value: Object to save the result of the calculation.
    &#34;&#34;&#34;
    best_action = self.get_best_action(pathfinding_actions, search_tree_actions)
    return_value.value = best_action.get_index() if best_action is not None else return_value.value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="chillow.service.ai.pathfinding_ai.PathfindingAI" href="pathfinding_ai.html#chillow.service.ai.pathfinding_ai.PathfindingAI">PathfindingAI</a></b></code>:
<ul class="hlist">
<li><code><a title="chillow.service.ai.pathfinding_ai.PathfindingAI.calc_action_with_max_distance_to_visited_cells" href="not_killing_itself_ai.html#chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.calc_action_with_max_distance_to_visited_cells">calc_action_with_max_distance_to_visited_cells</a></code></li>
<li><code><a title="chillow.service.ai.pathfinding_ai.PathfindingAI.create_next_action" href="not_killing_itself_ai.html#chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.create_next_action">create_next_action</a></code></li>
<li><code><a title="chillow.service.ai.pathfinding_ai.PathfindingAI.create_next_actions_ranked" href="pathfinding_ai.html#chillow.service.ai.pathfinding_ai.PathfindingAI.create_next_actions_ranked">create_next_actions_ranked</a></code></li>
<li><code><a title="chillow.service.ai.pathfinding_ai.PathfindingAI.find_actions_by_best_path_connection" href="pathfinding_ai.html#chillow.service.ai.pathfinding_ai.PathfindingAI.find_actions_by_best_path_connection">find_actions_by_best_path_connection</a></code></li>
<li><code><a title="chillow.service.ai.pathfinding_ai.PathfindingAI.find_surviving_actions" href="not_killing_itself_ai.html#chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.find_surviving_actions">find_surviving_actions</a></code></li>
<li><code><a title="chillow.service.ai.pathfinding_ai.PathfindingAI.find_surviving_actions_with_best_depth" href="not_killing_itself_ai.html#chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.find_surviving_actions_with_best_depth">find_surviving_actions_with_best_depth</a></code></li>
<li><code><a title="chillow.service.ai.pathfinding_ai.PathfindingAI.get_information" href="not_killing_itself_ai.html#chillow.service.ai.not_killing_itself_ai.NotKillingItselfAI.get_information">get_information</a></code></li>
<li><code><a title="chillow.service.ai.pathfinding_ai.PathfindingAI.get_random_free_cells_from_playground" href="pathfinding_ai.html#chillow.service.ai.pathfinding_ai.PathfindingAI.get_random_free_cells_from_playground">get_random_free_cells_from_playground</a></code></li>
</ul>
</li>
<li><code><b><a title="chillow.service.ai.search_tree_ai.SearchTreeAI" href="search_tree_ai.html#chillow.service.ai.search_tree_ai.SearchTreeAI">SearchTreeAI</a></b></code>:
<ul class="hlist">
<li><code><a title="chillow.service.ai.search_tree_ai.SearchTreeAI.create_all_next_surviving_actions" href="search_tree_ai.html#chillow.service.ai.search_tree_ai.SearchTreeAI.create_all_next_surviving_actions">create_all_next_surviving_actions</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="chillow.service.ai" href="index.html">chillow.service.ai</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="chillow.service.ai.pathfinding_search_tree_ai.PathfindingSearchTreeAI" href="#chillow.service.ai.pathfinding_search_tree_ai.PathfindingSearchTreeAI">PathfindingSearchTreeAI</a></code></h4>
<ul class="">
<li><code><a title="chillow.service.ai.pathfinding_search_tree_ai.PathfindingSearchTreeAI.get_best_action" href="#chillow.service.ai.pathfinding_search_tree_ai.PathfindingSearchTreeAI.get_best_action">get_best_action</a></code></li>
<li><code><a title="chillow.service.ai.pathfinding_search_tree_ai.PathfindingSearchTreeAI.set_best_action" href="#chillow.service.ai.pathfinding_search_tree_ai.PathfindingSearchTreeAI.set_best_action">set_best_action</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>